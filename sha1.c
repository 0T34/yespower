/*
By Steve Reid <sreid@sea-to-sky.net>
100% Public Domain

-----------------
Modified 7/98
By James H. Brown <jbrown@burgoyne.com>
Still 100% Public Domain

Corrected a problem which generated improper hash values on 16 bit machines
Routine SHA1Update changed from
	void SHA1Update(SHA1_CTX* context, unsigned char* data, unsigned int
len)
to
	void SHA1Update(SHA1_CTX* context, unsigned char* data, unsigned
long len)

The 'len' parameter was declared an int which works fine on 32 bit machines.
However, on 16 bit machines an int is too small for the shifts being done
against
it.  This caused the hash function to generate incorrect values if len was
greater than 8191 (8K - 1) due to the 'len << 3' on line 3 of SHA1Update().

Since the file IO in main() reads 16K at a time, any file 8K or larger would
be guaranteed to generate the wrong hash (e.g. Test Vector #3, a million
"a"s).

I also changed the declaration of variables i & j in SHA1Update to
unsigned long from unsigned int for the same reason.

These changes should make no difference to any 32 bit implementations since
an
int and a long are the same size in those environments.

--
I also corrected a few compiler warnings generated by Borland C.
1. Added #include <process.h> for exit() prototype
2. Removed unused variable 'j' in SHA1Final
3. Changed exit(0) to return(0) at end of main.

ALL changes I made can be located by searching for comments containing 'JHB'
-----------------
Modified 8/98
By Steve Reid <sreid@sea-to-sky.net>
Still 100% public domain

1- Removed #include <process.h> and used return() instead of exit()
2- Fixed overwriting of finalcount in SHA1Final() (discovered by Chris Hall)
3- Changed email address from steve@edmweb.com to sreid@sea-to-sky.net

-----------------
Modified 4/01
By Saul Kravitz <Saul.Kravitz@celera.com>
Still 100% PD
Modified to run on Compaq Alpha hardware.

-----------------
Modified 07/2002
By Ralph Giles <giles@artofcode.com>
Still 100% public domain
modified for use with stdint types, autoconf
code cleanup, removed attribution comments
switched SHA1Final() argument order for consistency
use SHA1_ prefix for public api
move public api to sha1.h
*/

#include <assert.h>
#include <stdint.h>
#include <string.h>

#include "sysendian.h"

#include "sha1.h"

void SHA1_Transform(uint32_t state[5], const uint8_t buffer[64]);

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

#if defined (BYTE_ORDER) && defined(BIG_ENDIAN) && (BYTE_ORDER == BIG_ENDIAN)
#define WORDS_BIGENDIAN 1
#endif
#ifdef _BIG_ENDIAN
#define WORDS_BIGENDIAN 1
#endif


/* blk0() and blk() perform the initial expand. */
/* I got the idea of expanding during the round function from SSLeay */
/* FIXME: can we do this in an endian-proof way? */
#ifdef WORDS_BIGENDIAN
#define blk0(i) block->l[i]
#else
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xff00ff00) \
         |(rol(block->l[i],8)&0x00ff00ff))
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
                     ^block->l[(i+2)&15]^block->l[i&15],1))

/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
#define R0(v, w, x, y, z, i) \
    z+=((w&(x^y))^y)+blk0(i)+0x5a827999+rol(v,5);w=rol(w,30);
#define R1(v, w, x, y, z, i) \
    z+=((w&(x^y))^y)+blk(i)+0x5a827999+rol(v,5);w=rol(w,30);
#define R2(v, w, x, y, z, i) \
    z+=(w^x^y)+blk(i)+0x6ed9eba1+rol(v,5);w=rol(w,30);
#define R3(v, w, x, y, z, i) \
    z+=(((w|x)&y)|(w&x))+blk(i)+0x8f1bbcdc+rol(v,5);w=rol(w,30);
#define R4(v, w, x, y, z, i) \
    z+=(w^x^y)+blk(i)+0xca62c1d6+rol(v,5);w=rol(w,30);


/* Hash a single 512-bit block. This is the core of the algorithm. */
void SHA1_Transform(uint32_t state[5], const uint8_t buffer[64]) {
    uint32_t a, b, c, d, e;
    typedef union {
        uint8_t c[64];
        uint32_t l[16];
    } CHAR64LONG16;
    CHAR64LONG16 *block;

    CHAR64LONG16 workspace;
    block = &workspace;
    memcpy(block, buffer, 64);

    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];

    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a, b, c, d, e, 0);
    R0(e, a, b, c, d, 1);
    R0(d, e, a, b, c, 2);
    R0(c, d, e, a, b, 3);
    R0(b, c, d, e, a, 4);
    R0(a, b, c, d, e, 5);
    R0(e, a, b, c, d, 6);
    R0(d, e, a, b, c, 7);
    R0(c, d, e, a, b, 8);
    R0(b, c, d, e, a, 9);
    R0(a, b, c, d, e, 10);
    R0(e, a, b, c, d, 11);
    R0(d, e, a, b, c, 12);
    R0(c, d, e, a, b, 13);
    R0(b, c, d, e, a, 14);
    R0(a, b, c, d, e, 15);
    R1(e, a, b, c, d, 16);
    R1(d, e, a, b, c, 17);
    R1(c, d, e, a, b, 18);
    R1(b, c, d, e, a, 19);
    R2(a, b, c, d, e, 20);
    R2(e, a, b, c, d, 21);
    R2(d, e, a, b, c, 22);
    R2(c, d, e, a, b, 23);
    R2(b, c, d, e, a, 24);
    R2(a, b, c, d, e, 25);
    R2(e, a, b, c, d, 26);
    R2(d, e, a, b, c, 27);
    R2(c, d, e, a, b, 28);
    R2(b, c, d, e, a, 29);
    R2(a, b, c, d, e, 30);
    R2(e, a, b, c, d, 31);
    R2(d, e, a, b, c, 32);
    R2(c, d, e, a, b, 33);
    R2(b, c, d, e, a, 34);
    R2(a, b, c, d, e, 35);
    R2(e, a, b, c, d, 36);
    R2(d, e, a, b, c, 37);
    R2(c, d, e, a, b, 38);
    R2(b, c, d, e, a, 39);
    R3(a, b, c, d, e, 40);
    R3(e, a, b, c, d, 41);
    R3(d, e, a, b, c, 42);
    R3(c, d, e, a, b, 43);
    R3(b, c, d, e, a, 44);
    R3(a, b, c, d, e, 45);
    R3(e, a, b, c, d, 46);
    R3(d, e, a, b, c, 47);
    R3(c, d, e, a, b, 48);
    R3(b, c, d, e, a, 49);
    R3(a, b, c, d, e, 50);
    R3(e, a, b, c, d, 51);
    R3(d, e, a, b, c, 52);
    R3(c, d, e, a, b, 53);
    R3(b, c, d, e, a, 54);
    R3(a, b, c, d, e, 55);
    R3(e, a, b, c, d, 56);
    R3(d, e, a, b, c, 57);
    R3(c, d, e, a, b, 58);
    R3(b, c, d, e, a, 59);
    R4(a, b, c, d, e, 60);
    R4(e, a, b, c, d, 61);
    R4(d, e, a, b, c, 62);
    R4(c, d, e, a, b, 63);
    R4(b, c, d, e, a, 64);
    R4(a, b, c, d, e, 65);
    R4(e, a, b, c, d, 66);
    R4(d, e, a, b, c, 67);
    R4(c, d, e, a, b, 68);
    R4(b, c, d, e, a, 69);
    R4(a, b, c, d, e, 70);
    R4(e, a, b, c, d, 71);
    R4(d, e, a, b, c, 72);
    R4(c, d, e, a, b, 73);
    R4(b, c, d, e, a, 74);
    R4(a, b, c, d, e, 75);
    R4(e, a, b, c, d, 76);
    R4(d, e, a, b, c, 77);
    R4(c, d, e, a, b, 78);
    R4(b, c, d, e, a, 79);

    /* Add the working vars back into context.state[] */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;

    /* Wipe variables */
    a = b = c = d = e = 0;
}


/**
* Initialize new context
*
* @param ctx SHA1-Context
*/
void SHA1_Init(SHA1_CTX *ctx) {
    /* SHA1 initialization constants */
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xefcdab89;
    ctx->state[2] = 0x98badcfe;
    ctx->state[3] = 0x10325476;
    ctx->state[4] = 0xc3d2e1f0;
    ctx->count[0] = ctx->count[1] = 0;
}


/**
* Run your data through this
*
* @param ctx     SHA1-Context
* @param p       Buffer to run SHA1 on
* @param len     Number of bytes
*/
void SHA1_Update(SHA1_CTX *ctx, const void *p, size_t len) {
    const uint8_t *data = p;
    size_t i, j;

    j = (ctx->count[0] >> 3) & 63;
    if ((ctx->count[0] += (uint32_t) (len << 3)) < (len << 3)) {
        ctx->count[1]++;
    }
    ctx->count[1] += (uint32_t) (len >> 29);
    if ((j + len) > 63) {
        memcpy(&ctx->buffer[j], data, (i = 64 - j));
        SHA1_Transform(ctx->state, ctx->buffer);
        for (; i + 63 < len; i += 64) {
            SHA1_Transform(ctx->state, data + i);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&ctx->buffer[j], &data[i], len - i);
}


/**
* Add padding and return the message digest
*
* @param d   Generated message digest
* @param ctx SHA1-Context
*/
void SHA1_Final(uint8_t d[SHA1_DIGEST_SIZE], SHA1_CTX *ctx) {
    uint32_t i;
    uint8_t finalcount[8];

    for (i = 0; i < 8; i++) {
        finalcount[i] = (uint8_t) ((ctx->count[(i >= 4 ? 0 : 1)]
                >> ((3 - (i & 3)) * 8)) & 255);
    }
    SHA1_Update(ctx, (uint8_t *) "\200", 1);
    while ((ctx->count[0] & 504) != 448) {
        SHA1_Update(ctx, (uint8_t *) "\0", 1);
    }
    SHA1_Update(ctx, finalcount, 8); /* Should cause SHA1_Transform */
    for (i = 0; i < SHA1_DIGEST_SIZE; i++) {
        d[i] = (uint8_t)
                ((ctx->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
    }

    /* Wipe variables */
    i = 0;
    memset(ctx->buffer, 0, 64);
    memset(ctx->state, 0, 20);
    memset(ctx->count, 0, 8);
    memset(finalcount, 0, 8);    /* SWR */

    /* make SHA1Transform overwrite its own static vars */
    SHA1_Transform(ctx->state, ctx->buffer);
}

/**
* Compute the SHA1 hash
* @param in      Buffer to run SHA1 on
* @param len     Number of bytes
* @param d  Generated message digest
*/
void SHA1_Buf(const void *in, size_t len, uint8_t d[SHA1_DIGEST_SIZE]) {
	SHA1_CTX ctx;

	SHA1_Init(&ctx);
	SHA1_Update(&ctx, in, len);
	SHA1_Final(d, &ctx);
}

/**
* Initialize new HMAC context
*
* @param ctx     HMAC Context
* @param k       Key
* @param len     Number of bytes
*/
void HMAC_SHA1_Init(HMAC_SHA1_CTX *ctx, const void *_k, size_t len) {
    const uint8_t *k = _k;
    uint8_t key[SHA1_DIGEST_SIZE];
    uint8_t buf[SHA1_BLOCKSIZE];
    size_t i;

    if (len > SHA1_BLOCKSIZE) {
        SHA1_Init(&ctx->ictx);
        SHA1_Update(&ctx->ictx, k, len);
        SHA1_Final(key, &ctx->ictx);

        k = key;
        len = SHA1_DIGEST_SIZE;
    }

    /**** Inner Digest ****/
    SHA1_Init(&ctx->ictx);

    /* Pad the key for inner digest */
    for (i = 0; i < len; ++i) {
        buf[i] = k[i] ^ 0x36;
    }
    for (i = len; i < SHA1_BLOCKSIZE; ++i) {
        buf[i] = 0x36;
    }

    SHA1_Update(&ctx->ictx, buf, SHA1_BLOCKSIZE);

    /**** Outer Digest ****/
    SHA1_Init(&ctx->octx);

    /* Pad the key for outter digest */
    for (i = 0; i < len; ++i) {
        buf[i] = k[i] ^ 0x5c;
    }
    for (i = len; i < SHA1_BLOCKSIZE; ++i) {
        buf[i] = 0x5c;
    }

    SHA1_Update(&ctx->octx, buf, SHA1_BLOCKSIZE);
}

/**
* Run your data through this
*
* @param ctx     HMAC Context
* @param p       Buffer to run HMAC on
* @param len     Number of bytes
*/
void HMAC_SHA1_Update(HMAC_SHA1_CTX *ctx, const void *p, size_t len) {
    SHA1_Update(&ctx->ictx, p, len);
}

/**
* Add padding and return the message digest
*
* @param digest  Generated message digest
* @param context HMAC Context
*/
void HMAC_SHA1_Final(uint8_t d[SHA1_DIGEST_SIZE], HMAC_SHA1_CTX *context) {
    uint8_t isha[SHA1_DIGEST_SIZE];

    SHA1_Final(isha, &context->ictx);
    SHA1_Update(&context->octx, isha, SHA1_DIGEST_SIZE);
    SHA1_Final(d, &context->octx);
}

/**
* Function to compute the digest
*
* @param k      Key
* @param klen   Key number of bytes
* @param in     Buffer to run HMAC on
* @param inlen  Buffer number of bytes
* @param d      Generated message digest
*/
void HMAC_SHA1_Buf(const void *k, size_t klen, 
                   const void *in, size_t inlen, uint8_t d[SHA1_DIGEST_SIZE]) {
    HMAC_SHA1_CTX ctx;

	HMAC_SHA1_Init(&ctx, k, klen);
	HMAC_SHA1_Update(&ctx, in, inlen);
	HMAC_SHA1_Final(d, &ctx);
}

/**
* Function to compute the digest
*
* @param passwd     Password
* @param passwdlen  Password number of bytes
* @param salt       Salt
* @param saltlen    Salt number of bytes
* @param c          Number of iterations
* @param buf        Buffer to run PBKDF2 on
* @param dkLen      Number of bytes for Key
*/
void PBKDF2_SHA1(const uint8_t *passwd, size_t passwdlen, const uint8_t *salt,
                 size_t saltlen, uint64_t c, uint8_t *buf, size_t dkLen) {
	HMAC_SHA1_CTX Phctx, PShctx, hctx;
	size_t i;
	uint8_t ivec[4];
	uint8_t U[SHA1_DIGEST_SIZE];
	uint8_t T[SHA1_DIGEST_SIZE];
	uint64_t j;
	int k;
	size_t clen;

	/* Sanity-check. */
	assert(dkLen <= SHA1_DIGEST_SIZE * (size_t)(UINT32_MAX));

	/* Compute HMAC state after processing P. */
	HMAC_SHA1_Init(&Phctx, passwd, passwdlen);

	/* Compute HMAC state after processing P and S. */
	memcpy(&PShctx, &Phctx, sizeof(HMAC_SHA1_CTX));
	HMAC_SHA1_Update(&PShctx, salt, saltlen);

	/* Iterate through the blocks. */
	for (i = 0; i * SHA1_DIGEST_SIZE < dkLen; i++) {
		/* Generate INT(i + 1). */
		be32enc(ivec, (uint32_t)(i + 1));

		/* Compute U_1 = PRF(P, S || INT(i)). */
		memcpy(&hctx, &PShctx, sizeof(HMAC_SHA1_CTX));
		HMAC_SHA1_Update(&hctx, ivec, 4);
		HMAC_SHA1_Final(T, &hctx);

		if (c > 1) {
			/* T_i = U_1 ... */
			memcpy(U, T, SHA1_DIGEST_SIZE);

			for (j = 2; j <= c; j++) {
				/* Compute U_j. */
				memcpy(&hctx, &Phctx, sizeof(HMAC_SHA1_CTX));
				HMAC_SHA1_Update(&hctx, U, SHA1_DIGEST_SIZE);
				HMAC_SHA1_Final(U, &hctx);

				/* ... xor U_j ... */
				for (k = 0; k < SHA1_DIGEST_SIZE; k++) {
					T[k] ^= U[k];
                }
			}
		}

		/* Copy as many bytes as necessary into buf. */
		clen = dkLen - i * SHA1_DIGEST_SIZE;
		if (clen > SHA1_DIGEST_SIZE) {
			clen = SHA1_DIGEST_SIZE;
        }

		memcpy(&buf[i * SHA1_DIGEST_SIZE], T, clen);
	}
}

